# AGENTS.md - Ralph Loop Agent Instructions

**For**: Little Money Buddy Web3 Application  
**Agent Target**: Claude Code / Autonomous Coding Agents  
**Version**: 1.0  
**Last Updated**: January 27, 2026

---

## 1. CORE PRINCIPLES

These principles govern ALL work by the autonomous agent. Follow them religiously.

### Priority Hierarchy (In Order of Importance)

1. **Type Safety** - TypeScript strict mode, no `any` types, explicit typing
2. **Code Quality** - Tests written first, linting passes, readable code
3. **Maintainability** - Follow patterns, clear naming, proper documentation
4. **Performance** - After quality is solid, optimize hot paths
5. **Delivery Speed** - Only after all above are satisfied

**Enforcement**: Fail fast on type errors. If TypeScript doesn't compile, nothing else matters.

---

## 2. CODE QUALITY STANDARDS

### TypeScript Standards

**REQUIRED - Non-negotiable:**
```typescript
// ✅ GOOD - Explicit types everywhere
interface User {
  id: string;
  walletAddress: `0x${string}`;
  email: string;
  createdAt: Date;
}

function getUserById(id: string): Promise<User | null> {
  // implementation
}

// ❌ BAD - Using any
interface User {
  id: any;
  data: any;
}

function getData(id): any {
  // implementation
}
```

**Rules:**
- `tsconfig.json` must have `"strict": true`
- Every function parameter must have explicit type
- Every function must have return type annotation
- Never use `any` - use `unknown` or proper interface instead
- Use `const` and `let` only - no `var`
- Use arrow functions for consistency
- Enums for options: `type Role = 'admin' | 'user';`

### Testing Standards

**Every function must have tests:**
```typescript
// src/lib/auth.ts
export function verifyWalletSignature(
  address: string,
  message: string,
  signature: string
): boolean {
  const recoveredAddress = ethers.verifyMessage(message, signature);
  return recoveredAddress.toLowerCase() === address.toLowerCase();
}

// src/lib/__tests__/auth.test.ts
describe('verifyWalletSignature', () => {
  it('returns true for valid signature', () => {
    const address = '0x742d35Cc6634C0532925a3b844Bc5e8f5A9cD9c7';
    const message = 'Sign in to Little Money Buddy';
    const signature = '0x...'; // Valid signature from this address
    
    const result = verifyWalletSignature(address, message, signature);
    expect(result).toBe(true);
  });

  it('returns false for invalid signature', () => {
    const address = '0x742d35Cc6634C0532925a3b844Bc5e8f5A9cD9c7';
    const message = 'Sign in to Little Money Buddy';
    const signature = '0x0000'; // Invalid signature
    
    const result = verifyWalletSignature(address, message, signature);
    expect(result).toBe(false);
  });
});
```

**Requirements:**
- Every critical function needs at least 2 test cases (happy path + error case)
- Test file located at `src/lib/__tests__/[function].test.ts`
- Minimum 80% coverage for files in `src/lib/`, 60% for components
- Run `npm run test` before committing - all must pass
- Use Jest + React Testing Library

### Linting & Formatting

**Before every commit:**
```bash
npm run lint          # Must pass with zero errors
npm run format        # Auto-formats with Prettier
npm run type-check    # tsc --noEmit - must pass
npm run test          # All tests must pass
npm run build         # next build - must succeed
```

**Rules:**
- No unused imports
- No console.log in production code (use proper logging)
- No trailing whitespace
- 2-space indentation (enforced by Prettier)
- 88-character line limit

### File Organization

**Pattern to follow:**
```
src/
├── components/
│   ├── WalletConnect.tsx          (Component itself)
│   ├── WalletConnect.test.tsx     (Component tests)
│   └── WalletConnect.module.css   (Component styles)
├── lib/
│   ├── auth.ts                    (Business logic)
│   ├── __tests__/
│   │   └── auth.test.ts           (Logic tests)
│   └── types.ts                   (Shared types)
├── hooks/
│   └── useWalletConnect.ts        (Custom hooks)
└── styles/
    └── globals.css                (Global styles)
```

---

## 3. WEB3 & BLOCKCHAIN SPECIFICS

### ethers.js v6 Standards

**Use ethers.js v6 - NOT web3.js**

```typescript
// ✅ CORRECT - ethers.js v6
import { ethers } from 'ethers';

const provider = new ethers.JsonRpcProvider(rpcUrl);
const balance = await provider.getBalance(address);
const signer = await provider.getSigner();

// ❌ WRONG - web3.js approach
const web3 = new Web3(rpcUrl);
const balance = await web3.eth.getBalance(address);
```

**Wallet Connection Pattern (ethers.js v6):**
```typescript
// src/lib/web3.ts
export async function connectWallet(): Promise<string> {
  if (!window.ethereum) {
    throw new Error('MetaMask not installed');
  }

  const provider = new ethers.BrowserProvider(window.ethereum);
  const accounts = await provider.send('eth_requestAccounts', []);
  
  if (accounts.length === 0) {
    throw new Error('No accounts found');
  }

  return accounts[0];
}

// Message signing for authentication
export async function signAuthMessage(
  address: string,
  message: string
): Promise<string> {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const signature = await signer.signMessage(message);
  return signature;
}
```

**Fetch Balances:**
```typescript
// src/lib/wallet.ts
export async function getWalletBalance(
  address: string,
  rpcUrl: string
): Promise<string> {
  const provider = new ethers.JsonRpcProvider(rpcUrl);
  const balance = await provider.getBalance(address);
  return ethers.formatEther(balance);
}

// Get token balance (requires contract ABI)
export async function getTokenBalance(
  tokenAddress: string,
  walletAddress: string,
  rpcUrl: string
): Promise<string> {
  const provider = new ethers.JsonRpcProvider(rpcUrl);
  const contract = new ethers.Contract(
    tokenAddress,
    ['function balanceOf(address) view returns (uint256)'],
    provider
  );
  
  const balance = await contract.balanceOf(walletAddress);
  return ethers.formatUnits(balance, 18); // 18 decimals for standard tokens
}
```

### Network Configuration

```typescript
// src/lib/chains.ts
export const CHAINS = {
  ethereum: {
    id: 1,
    name: 'Ethereum',
    rpc: process.env.NEXT_PUBLIC_ETHEREUM_RPC_URL,
    symbol: 'ETH',
    decimals: 18,
    blockTime: 12,
  },
  polygon: {
    id: 137,
    name: 'Polygon',
    rpc: process.env.NEXT_PUBLIC_POLYGON_RPC_URL,
    symbol: 'MATIC',
    decimals: 18,
    blockTime: 2,
  },
} as const;

export type ChainId = keyof typeof CHAINS;
```

### No Private Keys Ever

**CRITICAL SECURITY RULE:**
- Never ask user for private key
- Never store private key anywhere
- Only use wallet-based signing (MetaMask popup)
- All transactions initiated by user via wallet UI

```typescript
// ✅ CORRECT - User signs in wallet popup
const signer = await provider.getSigner();
const signature = await signer.signMessage(message);

// ❌ WRONG - Never do this
const wallet = new ethers.Wallet(privateKey);
const signature = wallet.signMessage(message);
```

---

## 4. APPWRITE INTEGRATION

### Database Operations

**Setup (one time in `src/lib/appwrite.ts`):**
```typescript
import { Client, Databases, Account } from 'appwrite';

const client = new Client();
client
  .setEndpoint(process.env.NEXT_PUBLIC_APPWRITE_ENDPOINT!)
  .setProject(process.env.NEXT_PUBLIC_APPWRITE_PROJECT_ID!);

export const databases = new Databases(client);
export const account = new Account(client);
export const APPWRITE_DB_ID = 'little-money-buddy';
```

**Create (Insert):**
```typescript
// src/lib/expenses.ts
export async function createExpense(
  userId: string,
  amount: number,
  category: string,
  description: string
): Promise<void> {
  await databases.createDocument(
    APPWRITE_DB_ID,
    'expenses',
    ID.unique(),
    {
      userId,
      amount,
      category,
      description,
      date: new Date().toISOString(),
      createdAt: new Date().toISOString(),
    }
  );
}
```

**Read (Query):**
```typescript
export async function getUserExpenses(
  userId: string,
  limit: number = 50
): Promise<Expense[]> {
  const response = await databases.listDocuments(
    APPWRITE_DB_ID,
    'expenses',
    [
      Query.equal('userId', userId),
      Query.orderDesc('date'),
      Query.limit(limit),
    ]
  );
  return response.documents as Expense[];
}
```

**Update:**
```typescript
export async function updateExpense(
  expenseId: string,
  updates: Partial<Expense>
): Promise<void> {
  await databases.updateDocument(
    APPWRITE_DB_ID,
    'expenses',
    expenseId,
    updates
  );
}
```

**Delete:**
```typescript
export async function deleteExpense(expenseId: string): Promise<void> {
  await databases.deleteDocument(
    APPWRITE_DB_ID,
    'expenses',
    expenseId
  );
}
```

### Error Handling Pattern

```typescript
export async function safeGetExpenses(userId: string): Promise<Expense[]> {
  try {
    const expenses = await getUserExpenses(userId);
    return expenses;
  } catch (error) {
    if (error instanceof AppwriteException) {
      if (error.code === 401) {
        // User not authenticated
        throw new Error('Unauthorized');
      }
      // Handle other Appwrite errors
      console.error('Appwrite error:', error.message);
    }
    throw error;
  }
}
```

---

## 5. API ROUTE PATTERNS (Next.js)

### Structure Pattern

```typescript
// src/app/api/expenses/route.ts
import { NextRequest, NextResponse } from 'next/server';
import type { NextApiRequest, NextApiResponse } from 'next';

export async function POST(req: NextRequest): Promise<NextResponse> {
  try {
    // Validate content type
    const contentType = req.headers.get('content-type');
    if (!contentType?.includes('application/json')) {
      return NextResponse.json(
        { error: 'Invalid content type' },
        { status: 400 }
      );
    }

    // Parse and validate request body
    const body = await req.json();
    const { amount, category, description } = body;

    if (!amount || !category || !description) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Get authenticated user (from session/cookie)
    const session = await getSession(req);
    if (!session?.userId) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Process request
    await createExpense(session.userId, amount, category, description);

    // Return success response
    return NextResponse.json(
      { message: 'Expense created' },
      { status: 201 }
    );
  } catch (error) {
    console.error('POST /api/expenses:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

export async function GET(req: NextRequest): Promise<NextResponse> {
  try {
    const session = await getSession(req);
    if (!session?.userId) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const expenses = await getUserExpenses(session.userId);
    return NextResponse.json(expenses);
  } catch (error) {
    console.error('GET /api/expenses:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### Rate Limiting

```typescript
// src/lib/rateLimit.ts
const requestCounts = new Map<string, { count: number; resetTime: number }>();

export function rateLimit(
  key: string,
  limit: number = 10,
  windowMs: number = 60000
): boolean {
  const now = Date.now();
  const userLimit = requestCounts.get(key);

  if (!userLimit || now > userLimit.resetTime) {
    requestCounts.set(key, { count: 1, resetTime: now + windowMs });
    return true;
  }

  if (userLimit.count >= limit) {
    return false;
  }

  userLimit.count++;
  return true;
}
```

---

## 6. REACT COMPONENT PATTERNS

### Function Component Template

```typescript
// src/components/WalletConnect.tsx
import React, { useState, useCallback } from 'react';

interface WalletConnectProps {
  onConnect: (address: string) => void;
  onError?: (error: Error) => void;
}

export function WalletConnect({
  onConnect,
  onError,
}: WalletConnectProps): JSX.Element {
  const [loading, setLoading] = useState<boolean>(false);

  const handleConnect = useCallback(async (): Promise<void> => {
    setLoading(true);
    try {
      const address = await connectWallet();
      onConnect(address);
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      onError?.(err);
    } finally {
      setLoading(false);
    }
  }, [onConnect, onError]);

  return (
    <button
      onClick={handleConnect}
      disabled={loading}
      className="btn btn-primary"
    >
      {loading ? 'Connecting...' : 'Connect Wallet'}
    </button>
  );
}
```

### Custom Hooks Pattern

```typescript
// src/hooks/useWalletBalance.ts
import { useState, useEffect } from 'react';
import { getWalletBalance } from '@/lib/wallet';

interface UseWalletBalanceOptions {
  address?: string;
  chainId?: number;
  pollInterval?: number;
}

interface UseWalletBalanceReturn {
  balance: string | null;
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
}

export function useWalletBalance({
  address,
  chainId = 1,
  pollInterval = 10000,
}: UseWalletBalanceOptions = {}): UseWalletBalanceReturn {
  const [balance, setBalance] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);

  const refetch = useCallback(async (): Promise<void> => {
    if (!address) return;

    setLoading(true);
    try {
      const rpc = getRpcUrl(chainId);
      const bal = await getWalletBalance(address, rpc);
      setBalance(bal);
      setError(null);
    } catch (err) {
      const e = err instanceof Error ? err : new Error(String(err));
      setError(e);
    } finally {
      setLoading(false);
    }
  }, [address, chainId]);

  useEffect(() => {
    refetch();
    const interval = setInterval(refetch, pollInterval);
    return () => clearInterval(interval);
  }, [refetch, pollInterval]);

  return { balance, loading, error, refetch };
}
```

---

## 7. GIT WORKFLOW

### Commit Message Format

```
[US-001] Add wallet connection button to landing page

- Implement MetaMask detection
- Add button with loading state
- Add proper error handling for missing wallet
- Add tests for wallet detection
- Update progress.txt

Closes US-001
```

**Rules:**
- Use format: `[US-XXX] Short description`
- Reference user story ID
- Include implementation details in bullet points
- Sign commits with `-S` for verification

### Branch Strategy

```bash
# Create feature branch for each user story
git checkout -b feature/us-001-wallet-connect

# Work on feature
# Add tests
# Run quality checks

# Push and create PR
git push origin feature/us-001-wallet-connect

# After review/approval, merge to main
git merge main
git push origin main
```

---

## 8. PROGRESS TRACKING

### Files to Maintain

**progress.txt:**
```
# Little Money Buddy - Development Progress
Last Updated: 2026-01-27

## Completed (US-001, US-002, US-003)
- Landing page with wallet connect button
- Wallet connection via MetaMask
- Backend wallet authentication endpoint
- Message signing verification

## Current (US-004)
- Session management and token validation
- Implementation 60% complete

## Next
- US-005: Dashboard layout
- US-006: Wallet balance display

## Blockers
None

## Learnings
- ethers.js v6 has breaking changes from web3.js
- Appwrite rate limiting docs are important to review
- Test coverage crucial for agent iterations
```

**prd.json (auto-generated):**
```json
{
  "project": "Little Money Buddy",
  "userStories": [
    {
      "id": "US-001",
      "title": "Landing Page & Wallet Connect Button",
      "phase": 1,
      "priority": 1,
      "passes": true,
      "completedAt": "2026-01-27T18:30:00Z"
    },
    {
      "id": "US-004",
      "title": "Session Management",
      "phase": 1,
      "priority": 1,
      "passes": false
    }
  ]
}
```

---

## 9. TROUBLESHOOTING GUIDE FOR AGENT

### "TypeScript errors after implementation"
- Check strict mode is enabled in tsconfig.json
- Verify all function parameters have types
- Run `npm run type-check` for full output
- Look for any `any` types and replace with proper types

### "Tests failing after changes"
- Run `npm run test` to see full output
- Each test file should match the implementation
- Verify mocks are set up correctly
- Check for async/await issues in tests

### "Can't connect to blockchain"
- Verify RPC URL in environment variables
- Test RPC endpoint with simple `curl` request
- Check network ID matches chain configuration
- Ensure provider is initialized before use

### "Appwrite errors (401, 403)"
- Verify API key is set in environment
- Check project ID is correct
- Confirm user permissions in Appwrite console
- Verify collection permissions allow the operation

### "MetaMask connection issues"
- Check if user denied permission
- Verify window.ethereum exists
- Test in Hardhat/local testnet if needed
- Check MetaMask network selection

---

## 10. QUALITY GATE CHECKLIST

**Before marking any story `passes: true`:**

- [ ] Feature implemented per acceptance criteria
- [ ] All unit tests written and passing
- [ ] Code passes linting (`npm run lint`)
- [ ] TypeScript compiles (`npm run type-check`)
- [ ] Full build succeeds (`npm run build`)
- [ ] No console errors/warnings in browser
- [ ] Manual testing completed (browser + mobile)
- [ ] Git commits written with proper messages
- [ ] progress.txt updated
- [ ] prd.json `passes` field set to true

**Quality enforcement:**
- If ANY check fails, do NOT proceed
- Fix issues before moving to next story
- Run full test suite before final commit

---

## 11. COMMUNICATION & FEEDBACK

### What the Agent Should Do

1. **After each iteration**: Update `progress.txt` with what was accomplished
2. **On blockers**: Document in progress.txt and STOP (don't override)
3. **On errors**: Log full error message, include context
4. **On success**: Make git commit with descriptive message
5. **On uncertainty**: Document assumption in progress.txt and proceed

### What the Agent Should Avoid

- ❌ Using `any` type to bypass errors
- ❌ Skipping tests to move faster
- ❌ Making changes outside assigned user story
- ❌ Committing without running quality checks
- ❌ Ignoring TypeScript errors
- ❌ Adding console.log in production code

---

## 12. EXECUTION COMMAND

Run Ralph Loop with these settings:

```bash
ralph-loop \
  --prd prd.md \
  --agents-md AGENTS.md \
  --max-iterations 50 \
  --max-cost 15.00 \
  --branch ralph/little-money-buddy \
  --completion-promise "<promise>COMPLETE</promise>"
```

---

**Version**: 1.0  
**Last Updated**: January 27, 2026  
**Status**: Ready for Agent Execution
